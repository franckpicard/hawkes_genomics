---
title: "flat_first.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(tidyverse)
library(parallel)
```

```{r development-load}
# Load already included functions if relevant
# pkgload::load_all(export_all = FALSE)
```


# Functions

## read_bed

```{r function-read_bed}
#' helper function for preprocess_bed to quickly load bed files
#'
#' @param path bed file path
#'
#' @return
#' tibble
read_bed <- function(path) {
  vroom::vroom(
    path,
    col_names = c("chr", "start", "stop"),
    col_types = list(chr = "c", start = "i", stop = "i"),
    col_select = c("chr", "start", "stop"),
  )
}
```

## filter_windows

```{r function-filter_windows}
#' helper function for preprocess_bed to compute a sliding windows along all
#' the beds and filter out position present in only one beds file
#'
#' @param data a tibble
#' @param maxlag the size of the windows
#'
#' @return
#' tibble
filter_windows <- function(data, maxlag) {
  data %>% 
    dplyr::group_by(chr) %>% 
    dplyr::arrange(start, stop, .by_group = T) %>% 
    dplyr::mutate(
      window = purrr::pmap_int(
        list(names, start, stop), function(names, start, stop, max_lag) {
          min(start) %/% max_lag + 1
        }, max_lag = maxlag)
    ) %>% 
    dplyr::group_by(chr, window) %>% 
    dplyr::mutate(
      count = length(levels(as.factor(names))),
    ) %>% 
    filter(count > 1) %>% 
    group_by(files) %>% 
    select(files, names, chr, start, stop) %>% 
    dplyr::mutate(
      interval_size = mean(stop - start)
    ) %>% 
    nest(beds = c(chr, start, stop))
}
```
## write_bed
```{r function-write_bed}
#' helper function for preprocess_bed to write bed files
#'
#' @param path a bed file path
#' @param data a tibble of bed information
#' @param outdir the path were to write the results
#' @param prefix (default: "clean_") the prefix of the preprocessed bed file
#'
#' @return
#' a path
write_bed <- function(path, data, outdir, prefix = "clean_") {
  path <- stringr::str_split(path, "/")[[1]]
  path <- stringr::str_c(outdir, "/", prefix, path[length(path)])
  print(path)
  vroom::vroom_write(
    data,
    file = path,
    delim = "\t",
    col_names = F,
    quote = "none"
  )
  return(path)
}
```

## preprocess_bed

```{r function-preprocess_bed}
#' preprocess_bed preprocess bed file to remove windows of size maxlag for chich
#' there is no signal or only signal in one sample
#'
#' @param files a vector of bed files path
#' @param names (default: files) a list of names for the sample
#' @param maxlag (default: 1e5) the size of the windows
#' @param prefix (default: "clean_") the prefix of the preprocessed bed file
#' @param outdir (default: "tempdir()") path for the preprocessed bed files
#'
#' @return
#' save a list of preprocessed bed files 
#' @export
#'
#' @examples
#' preprocess_bed(
#'   files = c(
#'     "inst/extdata/enhancer.bed",
#'     "inst/extdata/coding_prom.bed",
#'     "inst/extdata/sin3peaks.bed"
#'   ),
#'   names = c("enhancer", "prom", "sin3"),
#' )
preprocess_bed <- function(files, names = files, maxlag = 1e5, prefix = "", outdir = tempdir()) {
  tibble::tibble(
    files = files,
    names = names
  ) %>% 
    dplyr::mutate(
      bed = purrr::map(files, read_bed)
    ) %>%
  tidyr::unnest(cols = c(bed)) %>% 
  filter_windows(maxlag = maxlag) %>% 
  dplyr::mutate(
    preprocess_beds = purrr::map2(files, beds, write_bed, outdir = outdir, prefix = prefix)
  ) %>% 
  unnest(preprocess_beds)
}
```
## compute_hawkes_histogram

```{r function-compute_hawkes_histogram}
#' compute_hawkes_histogram
#'
#' @param files a vector of bed files path
#' @param K (default: 10) size of the histogram bins
#' @param delta (default: 1e4) max range to consider
#' @param kernel (default: "heterogeneous_interval") kernel for the computation
#'
#' @return
#' save a results file
#' @export
#'
#' @examples
compute_hawkes_histogram <- function(
    files, names = files, K = 10, delta = 1e4 , kernel = "heterogeneous_interval"){
  cmd <- c()
  for (bed in files) {
    cmd <- c(cmd, paste("-b", bed))
  }
  cmd <- c(cmd, paste("-histogram", K, delta))
  cmd <- c(cmd, paste("-kernel", kernel))
  cmd <- c(cmd, "-lambda 1")
  system2(
    "src/hawkes_bin",
    cmd,
    stdout = T
  ) %>% 
  textConnection() %>% 
  read.table(col.names = names) %>% 
  as.matrix()
}

```

## getparam

```{r function-getparam}
#' getparam
#'
#' @param data a matrix of parameters 
#' @return
#' Median of vector x
#' @export
#'
#' @examples
getparam <- function(data, K = 10) {
  data <- data[-1, ] # we remove the line corresponding to the nu's
  M <- ncol(data)
  ss <- seq(1, M * K, by = K)
  ee <- c((ss - 1)[2:M], M * K)
  a <- array(data = NA, dim = c(M, M, K))
  for (m in 1:M) {
    for (ell in 1:M) {
      a[m, ell, ] <- data[ss[ell]:ee[ell], m]  # proba d'observer des occurrences de m en plus après avoir observé des occurrences de ell
    }
  }
  return(a)
}
getparam2 <- function(data, K = 10, delta = 1e4) {
  res %>% 
    as_tibble() %>% 
    dplyr::slice(2:n()) %>% 
    dplyr::mutate(
      vs_name = rep(1:ncol(.), each = K),
      start = rep(rep(0:(K - 1)), ncol(.)) * delta * 2 + 1,
      stop = rep(rep(1:K), ncol(.)) * delta * 2
    ) %>% 
    dplyr::mutate(
      vs_name = levels(as.factor(colnames(res)))[vs_name],
    ) %>% 
    tidyr::pivot_longer(cols = !c(vs_name, start, stop)) %>% 
    dplyr::relocate(name) %>% 
    dplyr::arrange(name, vs_name, start, stop)
  
}
```


## uniform_kernel

```{r function-uniform_kernel}
#' the uniform kernel of width width 
#'
#' @param x vector of data
#' @param width width of the uniform kernel
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
uniform_kernel <- function(x, width){
  1 * (abs(x) <= width) / width
}
```

## triple_convolution

```{r function-triple_convolution}
#' the uniform kernel of width width 
#'
#' @param position position on which to convolve
#' @param x interaction function parameter
#' @param width width of the uniform kernel for the first process
#' @param vs_width width of the uniform kernel for the second process 
#' @param delta (default: 1e4) max range to consider
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
triple_convolution <- function(position, x, width, vs_width, delta = 1e4){
  (x / sqrt(delta)) %>% 
    convolve( uniform_kernel( position, width ) ) %>% 
    convolve( uniform_kernel( position, vs_width ) )
}
```

## hw

```{r function-hw}
#' hw convolution of the h interaction function with the kernel of the 2
#' processus
#'
#' @param a
#' @param K
#' @param delta
#' @param eta_m 
#' @param eta_ell 
#' 
#' @return
#' Median of vector x
#' @export
#'
#' @examples
hw <- function(a, K, delta, eta_m, eta_ell) {
  w_ell <- sapply(
    1:(2 * K * delta),
    FUN = function(x) {
      uniform_kernel(x, eta_ell)
    }
  )
  w_m <- sapply(
    1:(2 * K * delta),
    FUN = function(x) {
      uniform_kernel(x, eta_m)
    }
  )
  hh <- rep(a, each = 2 * delta)
  convolve(w_ell, convolve(w_m, hh))
}
```

## convolve_with_kernel

```{r function-convolve_with_kernel}
#' hw convolution of the h interaction function with the kernel of the 2
#' processus
#'
#' @param data results of compute_hawkes_histogram
#' @param width a vector of beds interval width (in the same orde as the data columns)
#' @param K (default: 10) size of the histogram bins
#' @param delta (default: 1e4) max range to consider
#' 
#' @return
#' tibble
#' @export
#'
#' @examples
convolve_with_kernel <- function(data, width, K = 10, delta = 1e4) {
  getparam2(data, K = K, delta = delta) %>% 
  dplyr::group_by(name, vs_name) %>% 
  dplyr::mutate(
    width = purrr::map_dbl(name, function(x, width = width, names = names){
        width[which(names == x)]
      }, width = width, names = colnames(data)
    ),
    vs_width = purrr::map_dbl(vs_name, function(x, width = width, names = names){
        width[which(names == x)]
      }, width = width, names = colnames(data)
    )
    
  ) %>% 
  dplyr::group_by(name, vs_name) %>% 
  tidyr::nest(params = c(value, width, vs_width, start, stop)) %>% 
  dplyr::mutate(
    convolution = purrr::map(
      params,
      function(params, delta = delta, K = K){
         params %>%
          dplyr::mutate(
            position = purrr::map2(
              start, stop, function(x, y){x:y})
          ) %>%
          unnest(c(position)) %>%
          dplyr::mutate(
            convolution = triple_convolution(position, value, width, vs_width, delta)
          ) %>%
        select(c(position, convolution)) %>% 
        dplyr::mutate(
          position = position - max(position) / 2,
        )
      }, delta = delta, K = K
    )
  )
}

```

## plot_convolution

```{r function-plot_convolution}
#' hw convolution of the h interaction function with the kernel of the 2
#' processus
#'
#' @param data results of compute_hawkes_histogram
#' @param width a vector of beds interval width (in the same orde as the data columns)
#' @param K (default: 10) size of the histogram bins
#' @param delta (default: 1e4) max range to consider
#' 
#' @return
#' tibble
#' @export
#'
#' @examples
plot_convolution <- function(data, width, K = 10, delta = 1e4, perc = .1){
  data <- convolve_with_kernel(
    data = data, width = width, K = K, delta = delta
    ) %>% 
    tidyr::unnest(convolution) %>% 
    dplyr::mutate(
      title = paste(name, "->", vs_name, "|", paste(setdiff(beds$names, c(name, vs_name)), collapse = ", "))
    )
  ggplot2::ggplot() +
  ggplot2::geom_vline(xintercept = 0, color = "gray", size = 0.5, linetype = "dashed") +
  ggplot2::geom_hline(yintercept = 0, color = "gray", size = 0.5) +
  ggplot2::geom_ribbon(
    data = data %>% filter(convolution >= 0),
    ggplot2::aes(x = position, ymin = 0, ymax = convolution),
    fill = "#EABDBA", color = "black") +
  ggplot2::geom_ribbon(
    data = data %>% filter(convolution <= 0),
    ggplot2::aes(x = position, ymin = convolution, ymax = 0),
    fill = "#8EBBF5", color = "black") +
  ggplot2::facet_wrap(~title, scales = "free_y") +
  ggplot2::theme_bw() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1))
}
```
## convolve_to_histogram

```{r function-convolve_to_histogram}
#' compute_hawkes_histogram
#'
#' @param res results from compute_hawkes_histogram
#' @param eta vector of bed interval size means
#' @param K (default: 10) size of the histogram bins
#' @param delta (default: 1e4) max range to consider
#'
#' @return
#' save a results file
#' @export
#'
#' @examples
convolve_to_histogram <- function(res, eta, K = 10, delta = 1e4) {
  a <- getparam(res)
  x <- c(1:(K * delta))
  x <- c(-x[length(x):1], x)
  pp <- colnames(res)
  ww = lapply(
    1:ncol(res),
    FUN = function(i) {
      lapply(
        1:ncol(res),
        FUN = function(j, pp = pp, x = x, K = K, delta = delta, eta = eta) {
          hh = hw(a[i, j, ] / sqrt(delta), K, delta, eta[i], eta[j])
          data.frame(
            h = hh[seq(1, length(x), by = 100)],
            x = x[seq(1, length(x), by = 100)],
            pp1 = pp[i],
            pp2 = pp[j]
          )
        }, pp = pp, x = x, K = K, delta = delta, eta = eta
      )
    }
  )
  ww = Reduce("rbind", Reduce("rbind", ww))
}
```

# Example

## preprocess data
```{r load_cecile_data}
beds <- preprocess_bed(
  files = c(
    "./inst/extdata/enhancer.bed",
    "./inst/extdata/coding_prom.bed",
    "./inst/extdata/sin3peaks.bed"
  ),
  names = c("enhancer", "prom", "sin3"),
)
beds
```

## hawkes computation

```{r compute_hitogram}
res <- compute_hawkes_histogram(
  files = beds$preprocess_beds,
  names = beds$names
)
```

## plot data


```{r plot_histogram}
plot_convolution(res, width = beds$interval_size)
```
