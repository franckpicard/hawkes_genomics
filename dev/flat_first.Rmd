---
title: "flat_first.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r development, include=FALSE}
library(tidyverse)
library(parallel)
```

```{r development-load}
# Load already included functions if relevant
# pkgload::load_all(export_all = FALSE)
```


# Functions

## read_bed

```{r function-read_bed}
#' helper function for preprocess_bed to quickly load bed files
#'
#' @param path bed file path
#'
#' @return
#' tibble
read_bed <- function(path) {
  vroom::vroom(
    path,
    col_names = c("chr", "start", "stop"),
    col_types = list(chr = "c", start = "i", stop = "i"),
    col_select = c("chr", "start", "stop"),
  )
}
```

## filter_windows

```{r function-filter_windows}
#' helper function for preprocess_bed to compute a sliding windows along all
#' the beds and filter out position present in only one beds file
#'
#' @param data a tibble
#' @param maxlag the size of the windows
#'
#' @return
#' tibble
filter_windows <- function(data, maxlag) {
  data %>% 
    dplyr::group_by(chr) %>% 
    dplyr::arrange(start, stop, .by_group = T) %>% 
    dplyr::mutate(
      window = purrr::pmap_int(
        list(names, start, stop), function(names, start, stop, max_lag) {
          min(start) %/% max_lag + 1
        }, max_lag = maxlag)
    ) %>% 
    dplyr::group_by(chr, window) %>% 
    dplyr::mutate(
      count = length(levels(as.factor(names))),
    ) %>% 
    filter(count > 1) %>% 
    group_by(files) %>% 
    select(files, chr, start, stop) %>% 
    nest(beds = c(chr, start, stop))
}
```
## write_bed
```{r function-write_bed}
#' helper function for preprocess_bed to write bed files
#'
#' @param path a bed file path
#' @param data a tibble of bed information
#' @param outdir the path were to write the results
#' @param prefix (default: "clean_") the prefix of the preprocessed bed file
#'
#' @return
#' a path
write_bed <- function(path, data, outdir, prefix = "clean_") {
  path <- stringr::str_split(path, "/")[[1]]
  path <- stringr::str_c(outdir, "/", prefix, path[length(path)])
  vroom::vroom_write(
    data,
    file = path,
    delim = "\t",
    col_names = F,
    quote = "none"
  )
  return(path)
}
```

## preprocess_bed

```{r function-preprocess_bed}
#' preprocess_bed preprocess bed file to remove windows of size maxlag for chich
#' there is no signal or only signal in one sample
#'
#' @param files a vector of bed files path
#' @param names (default: files) a list of names for the sample
#' @param maxlag (default: 1e5) the size of the windows
#' @param prefix (default: "clean_") the prefix of the preprocessed bed file
#' @param outdir (default: "./") path for the preprocessed bed files
#'
#' @return
#' save a list of preprocessed bed files 
#' @export
#'
#' @examples
#' preprocess_bed(
#'   files = c(
#'     "inst/extdata/enhancer.bed",
#'     "inst/extdata/coding_prom.bed",
#'     "inst/extdata/sin3peaks.bed"
#'   ),
#'   names = c("enhancer", "prom", "sin3"),
#' )
preprocess_bed <- function(files, names = files, maxlag = 1e5, prefix = "clean_", outdir = "./") {
  tibble::tibble(
    files = files,
    names = names
  ) %>% 
    dplyr::mutate(
      bed = purrr::map(files, read_bed)
    ) %>%
  tidyr::unnest(cols = c(bed)) %>% 
  filter_windows(maxlag = maxlag) %>% 
  dplyr::mutate(
    preprocess_beds = purrr::map2(files, beds, write_bed, outdir = outdir, prefix = prefix)
  ) %>% 
  unnest(preprocess_beds)
}
```

## compute_hawkes_overlap

```{r function-compute_hawkes_overlap}
#' My median
#'
#' @param x Vector of Numeric values
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
compute_hawkes_overlap <- function(
    K, delta, kernel, processes, path_data, path_results, ofile_prefix){
  if (!is.numeric(K)) {stop("K should be numeric")}
  
  files.regions.in <- paste(
    path_data, "/", processes, "_preprocessed.bed", sep = ""
  )
  
  file.option <- paste(
    rep(" -f", length(files.regions.in)), files.regions.in, collapse = ""
  )
  file.out.hawkes <- paste(
    path_results, "/", ofile_prefix, "_forward_K_", K, "_delta_", delta,
    "_kernel_", kernel, ".txt", sep = ""
  )
  command <- paste(
    path_soft, " ", file.option, " -dump-intermediate-values -histogram ",
    K, " ", delta, " -kernel ", kernel, " -lambda 1 > ", file.out.hawkes,
    sep = ""
  )
  system(command)
  
  file.option <- paste(
    rep(" -b", length(files.regions.in)), files.regions.in, collapse = ""
  )
  file.out.hawkes <- paste(
    path_results, "/", ofile_prefix, "_backward_K_", K, "_delta_", delta,
    "_kernel_", kernel, ".txt", sep = ""
  )
  command <- paste(
    path_soft, " ", file.option, " -dump-intermediate-values -histogram ",
    K, " ", delta, " -kernel ", kernel, " -lambda 1 > ", file.out.hawkes,
    sep = ""
  )  
  system(command)
}
```

## getparam_overlap

```{r function-getparam_overlap}
#' getparam_overlap
#'
#' @param M 
#' @param K
#' @param ofile
#' @param normalize
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
getparam_overlap <- function(M, K, ofile, normalize = FALSE) {
  # les colonnes sont en m
  Res <- scan(ofile, n = (M * M * K + M), what = "character", skip = 1)
  
  Res <- t(matrix(as.numeric(Res), nrow = M, ncol = M * K + 1))
  nu  <- Res[1,]
  Res <- Res[-1,]
  
  ss <- seq(1, M * K, by = K)
  ee <- c((ss - 1)[2:M], M * K)
  a <- array(data = NA, dim = c(M, M, K))
  for (m in 1:M) {
    for (ell in 1:M) {
      a[m, ell,] <-
        Res[ss[ell]:ee[ell], m]  # proba d'observer des occurrences de m en plus après avoir observé des occurrences de ell
    }
  }
  if (normalize) {
    for (m in 1:M) {
      for (ell in 1:M) {
        a[m, ell,] <- a[m, ell,] / nu[m]
      }
    }
  }
  return(a)
}
```

## results_hawkes_overlap

```{r function-results_hawkes_overlap}
#' results_hawkes_overlap
#'
#' @param K
#' @param delta 
#' @param kernel 
#' @param processes
#' @param path_data
#' @param path_results
#' @param ofile_prefix
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
results_hawkes_overlap = function(
    K, delta, kernel, processes, path_data, path_results, ofile_prefix){  
  M <- length(processes)
  af <- getparam_overlap(
    M, K, paste(
      path_results, "/", ofile_prefix, "_forward_K_", K, "_delta_", delta,
      "_kernel_", kernel, ".txt", sep = ""
    ),
    normalize = FALSE
  )
  ab <- getparam_overlap(
    M, K, paste(
      path_results, "/", ofile_prefix, "_backward_K_", K, "_delta_", delta,
      "_kernel_", kernel, ".txt", sep = ""
    ),
    normalize = FALSE
  )
  a <- merge_fb(af, ab)
  return(a)
}
```

## compute_hawkes_histogram

```{r function-compute_hawkes_histogram}
#' compute_hawkes_histogram
#'
#' @param files a vector of bed files path
#' @param output_file file path for the results
#' @param K (default: 10) size of the histogram bins
#' @param delta (default: 1e4) max range to consider
#' @param kernel (default: "heterogeneous_interval") kernel for the computation
#'
#' @return
#' save a results file
#' @export
#'
#' @examples
compute_hawkes_histogram <- function(
    files, output_file, K = 10, delta = 1e4 , kernel = "heterogeneous_interval"){
  cmd <- c()
  for (bed in files) {
    cmd <- c(cmd, paste("-b", bed))
  }
  cmd <- c(cmd, paste("-histogram", K, delta))
  cmd <- c(cmd, paste("-kernel", kernel))
  cmd <- c(cmd, "-lambda 1")
  system2(
    "src/hawkes_bin",
    cmd,
    stdout = T
  ) %>% 
  textConnection() %>% 
  read.table(col.names = files) %>% 
  as.matrix()
}

```

## results_hawkes_histogram

```{r function-results_hawkes_histogram}
#' results_hawkes_histogram
#'
#' @param K
#' @param delta 
#' @param kernel 
#' @param processes
#' @param path_data
#' @param path_results
#' @param ofile_prefix
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
results_hawkes_histogram = function(
    K, delta, kernel, processes, path_data, path_results, ofile_prefix) {
  af <- getparam(
    paste(
      path_results, "/", ofile_prefix, "_forward_K_", K, "_delta_", delta,
      "_kernel_", kernel, ".txt", sep = ""
    ),
    normalize = TRUE
  )
  ab <- getparam(
    paste(
      path_results, "/", ofile_prefix, "_backward_K_", K, "_delta_", delta,
      "_kernel_", kernel, ".txt", sep = ""
    ),
    normalize = TRUE
  )
  a <- merge_fb(af, ab)
  return(a)
}
```

## getparam

```{r function-getparam}
#' getparam
#'
#' @param ofile 
#' @param normalize (default: FALSE) 
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
getparam <- function(data, normalize = FALSE, K = 10) {
  # les colonnes sont en m
  nu <- unlist(data[1, ])
  Res <- data[-1, ]
  M <- ncol(data)
  ss <- seq(1, M * K, by = K)
  ee <- c((ss - 1)[2:M], M * K)
  a <- array(data = NA, dim = c(M, M, K))
  for (m in 1:M) {
    for (ell in 1:M) {
      a[m, ell, ] <- data[ss[ell]:ee[ell], m]  # proba d'observer des occurrences de m en plus après avoir observé des occurrences de ell
    }
  }
  if (normalize) {
    for (m in 1:M) {
      for (ell in 1:M) {
        a[m, ell, ] <- a[m, ell, ] / nu[m]
      }
    }
  }
  return(a)
}
```

## merge_fb

```{r function-merge_fb}
#' merge_fb
#'
#' @param af 
#' @param ab
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
merge_fb <- function(af, ab) {
  K <- dim(af)[3]
  M <- dim(af)[1]
  aa <- array(data = NA, dim = c(M, M, 2 * K))
  for (m in 1:M) {
    for (ell in 1:M) {
      aa[m, ell, ] <- c(ab[m, ell, K:1], af[m, ell, 1:K])
    }
  }
  return(aa)
}
```

## W

```{r function-W}
#' W
#'
#' @param x
#' @param eta
#'
#' @return
#' Median of vector x
#' @export
#'
#' @examples
W <- function(x, eta){
  1 * (abs(x) <= eta) / eta
}
```

## hw

```{r function-hw}
#' hw
#'
#' @param a
#' @param K
#' @param delta
#' @param eta_m 
#' @param eta_ell 
#' 
#' @return
#' Median of vector x
#' @export
#'
#' @examples
hw <- function(a, K, delta, eta_m, eta_ell) {
  w_ell <- sapply(
    1:(2 * K * delta),
    FUN = function(x) {
      W(x, eta_ell)
    }
  )
  w_m <- sapply(
    1:(2 * K * delta),
    FUN = function(x) {
      W(x, eta_m)
    }
  )
  hh <- rep(a, each = delta)
  convolve(w_ell, convolve(w_m, hh))
}
a[1, 1, ]
hw(a[1, 1, ] / sqrt(delta), K, delta, eta[1], eta[1])
```

# Example

We load plotting packages

```{r example-load_package}
library(ggplot2)
library(grid)
library(gridExtra)
library(RColorBrewer)
library(ggpubr)
```

set ggplot theme

```{r example-set_theme}
mytheme<- function(){
  theme(
    legend.title      = element_blank(),
    legend.background = element_blank(),
    legend.text       = element_text(size=10),
    legend.key.size   = unit(0.5,"cm"),
    axis.text.x       = element_text(size = 8,angle = 0,hjust=0.5,vjust=0.5),    
    axis.title.x      = element_text(size=8),
    axis.title.y      = element_blank(),
    axis.text.y       = element_text(size=8,hjust=0.5),
    plot.margin       = unit(rep(0.2,4), "lines"),
    panel.background  = element_rect(fill=NA,color="black"),
    #strip.background  = element_rect(fill="white",color="black"),
    strip.background = element_blank(),
    panel.border      = element_rect(fill = NA, color = NA),
    strip.text        = element_text(size=8),
    plot.title        = element_text(hjust=0.5),
    strip.text.x = element_text(size = 8),
    strip.text.y = element_text(size = 8),
    
  )
}
```

# load Cecile data

## preprocess data
```{r load_cecile_data}
beds <- preprocess_bed(
  files = c(
    "inst/extdata/enhancer.bed",
    "inst/extdata/coding_prom.bed",
    "inst/extdata/sin3peaks.bed"
  ),
  names = c("enhancer", "prom", "sin3"),
)
beds
```
## hawkes computation

```{r compute_hitogram}
res <- beds$preprocess_beds %>% 
compute_hawkes_histogram(
  output_file = "cecile.hist" 
)
res
```

## get params

```{r format_results}
params <- res %>%
  getparam()
params
```

## plot data

```{r analyse_cecile_data}
eta    = c(1400, 1, 560)
K      = 10
delta  = 10000
kernel = "heterogeneous_interval"

x  = c(1:(K * delta))
x  = c(-x[length(x):1], x)
a = params

pp = c("enh", "prom", "sin3")
# ww = mclapply(
ww = lapply(
  1:3,
  FUN = function(i) {
    # mclapply(
    lapply(
      1:3,
      FUN = function(j) {
        hh = hw(a[i, j, ] / sqrt(delta), K, delta, eta[i], eta[j])
        data.frame(
          h = hh[seq(1, length(x), by = 100)],
          x = x[seq(1, length(x), by = 100)],
          pp1 = pp[i],
          pp2 = pp[j]
        )
      }
    )
  }
)
ww = Reduce("rbind", Reduce("rbind", ww))


gg = list()
h  = 0
for (Fi in  c("enh", "prom", "sin3")) {
  for (Fj in  c("enh", "prom", "sin3")) {
    h       = h + 1
    gg[[h]] = ggplot(ww[(ww$pp1 == Fi) &
                          (ww$pp2 == Fj), ], aes(
                            x = x / 1000,
                            y = h,
                            color = method
                          )) +
      geom_vline(xintercept = 0,
                 color = "gray",
                 size = 0.5) + geom_line(color = "black") +
      xlab("position kb") + ylab("") + xlab("") +
      mytheme()
  }
}
gg[[1]] = gg[[1]] + ggtitle(expression("enhancer" %->% "enhancer | prom, sin3"))
gg[[2]] = gg[[2]] + ggtitle(expression("prom"  %->% "enhancer | sin3"))
gg[[3]] = gg[[3]] + ggtitle(expression("sin3" %->% "enhancer | prom")) + geom_hline(yintercept =
                                                                                      0,
                                                                                    color = "gray",
                                                                                    size = 0.5)
gg[[4]] = gg[[4]] + ggtitle(expression("enhancer" %->% "prom | sin3"))
gg[[5]] = gg[[5]] + ggtitle(expression("prom" %->%  "prom | enhancer,sin3"))
gg[[6]] = gg[[6]] + ggtitle(expression("sin3" %->% "prom | enhancer")) + geom_hline(yintercept =
                                                                                      0,
                                                                                    color = "gray",
                                                                                    size = 0.5)
gg[[7]] = gg[[7]] + ggtitle(expression("enhancer" %->% "sin3 | prom")) + geom_hline(yintercept =
                                                                                      0,
                                                                                    color = "gray",
                                                                                    size = 0.5)
gg[[8]] = gg[[8]] + ggtitle(expression("prom" %->%  "sin3 | enhancer")) + geom_hline(yintercept =
                                                                                       0,
                                                                                     color = "gray",
                                                                                     size = 0.5)
gg[[9]] = gg[[9]] + ggtitle(expression("sin3" %->% "sin3 | enhancer,prom")) + geom_hline(yintercept =
                                                                                           0,
                                                                                         color = "gray",
                                                                                         size = 0.5)
gg = grid.arrange(gg[[1]], gg[[2]], gg[[3]], gg[[4]], gg[[5]], gg[[6]], gg[[7]], gg[[8]], gg[[9]])
```
